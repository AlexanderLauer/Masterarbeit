\section*{Abstract}
Model-driven software engineering is a suitable method for dealing with the ever-in\-crea\-sing complexity of software development processes. 
Graphs and graph transformations have proven useful for representing such models and changes to them. 
These models must satisfy certain sets of constraints. An example are the multiplicities of a class structure. 
During the development process, a change to a model may result in an inconsistent model that must at some point be repaired.
This problem is called \emph{model repair}. In particular, we will consider \emph{rule-based graph repair} which is defined as follows: Given a graph $G$, a constraint $c$ such that $G$ does not satisfy $c$, and a set of rules $\mathcal{R}$, use the rules of $\mathcal{R}$ to transform $G$ into a graph that satisfies $c$.

Known notions of consistency have either viewed consistency as a binary property, either a graph is consistent w.r.t. a constraint $c$ or not, or only viewed the number of violations of the first graph of a constraint.
In this thesis, we introduce new notions of consistency, which we call \emph{consistency-maintaining} and \emph{consistency-increasing} transformations and rules, respectively. This is based on the possibility that a constraint can be satisfied up to a certain nesting level. 
Our notion considers the graphs of the first unsatisfied nesting level and is more fine-grained than those already known. Finer in the sense that also the smallest changes, insertions or deletions of individual edges or nodes can be considered as increasing or decreasing consistency.
Furthermore, we extend these notions to \emph{direct consistency-maintaining} and \emph{direct consistency-maintaining} transformations and rules respectively, which prohibit the insertion of new violations altogether, and compare our notions with the existing ones to reveal connections and differences.

We present methods for constructing application conditions that are \emph{direct con\-sis\-ten\-cy-maintaining} or \emph{direct consistency-increasing at layer}, respectively. In the latter case, we present two types of application conditions, one for general rules and one for a particular set of rules, which we call \emph{basic increasing rules}. These application conditions for basic rules are less complex and restrictive than the ones for general rules. The notion of direct consistency-increasing at layer is a weaker version of direct consistency-increasing which allows the construction of less complex application conditions.

Finally, we present an \emph{rule-based graph repair} approach that is able to repair certain constraints, which we call \emph{circular conflict-free constraints}, and certain sets of constraints, which we call \emph{circular conflict-free set of constraints}. Intuitively, a constraint $c$ is \emph{circular conflict free}, if there is an ordering $C_0, \ldots, C_n$ of all graphs of $c$ such that there is no $j<i$ such that a repair of $C_i$ leads to the insertion of a new violation of $C_j$. Analogously, a set of constraint $\mathcal{C}$ is \emph{circular conflict free}, if there is an ordering $c_1, \ldots, c_n$ of all constraints of $\mathcal{C}$ such that there is no $j <i$ such that a repair of $c_i$ at all graphs satisfying $c_j$ leads to a graph  not satisfying $c_j$.
\section*{Zusammenfassung}
Model-driven software engineering ist eine geeignete Methode, um die ständig wachsende Komplexität von Softwareentwicklungsprozessen zu bewältigen. 
Graphen und Graphtransformationen haben sich bewährt, um solche Modelle und Änderungen der Modelle darzustellen. 
Diese Modelle müssen bestimmte Mengen von Bedingungen (constraints) erfüllen. Ein einfachen Beispiel hierfür sind die Multiplizitäten einer Klassenstruktur. 
Während des Entwicklungsprozesses kann eine Änderung eines Modelles jedoch zu einem inkonsistenten Modell führen, welches wieder in ein konsistentes Modell überführt werden muss. 
Dieses Problem heißt \emph{model repair}. Insbesondere betrachten wir das \emph{rules-based graph repair} Problem, welches folgendermaßen definiert ist: Seien ein Graph $G$, ein constraint $c$, sodass $G$ nicht $c$ erfüllt, und eine Menge von Regeln $\mathcal{R}$ gegeben, verwende die Regeln von $\mathcal{R}$, um einen Graphen zu konstruieren, der $c$ erfüllt. 

Bereits bekannte Konzepte von Konsistenz haben Konsistenz entweder als binäre Eigenschaft, entweder ein Graph ist konsistent oder nicht, oder nur den ersten Graphen eines constraints betrachtet. 
In dieser Arbeit führen wir neue Begriffe von Konsistenz ein, die wir \emph{consistency-maintaining} bzw. \emph{consistency-increasing} Transformationen und Regeln nennen. Diese basieren auf der Möglichkeit, dass constraints bis zu einem bestimmten nesting level erfüllt sein können. Unsere Begriffe betrachten daher die Graphen des ersten nicht erfüllten nesting levels und sind feiner im Vergleich zu den bereits bekannten Begriffen. Feiner in dem Sinne, dass auch kleinste Änderungen, das Einfügen oder Löschen von einzelnen Kanten oder Knoten als eine Vergrößerung oder Verschlechterung der Konsistenz angesehen werden kann. 
Des Weiteren erweitern wir diese Begriffe zu den Begriffen \emph{direct consistency-maintaining} bzw. \emph{direct consistency-increasing} Transformationen und Regeln, die das Einfügen von neuen Verletzungen gänzlich verbieten, und vergleichen unsere Begrifflichkeiten mit den bereits existierenden, um Zusammenhänge und Unterschiede aufzudecken.

Wir präsentieren Methoden, um Awendungsbedingungen zu konstruieren, die \emph{direct consistency-maintaining} bzw. \emph{direct consistency-increasing at layer} sind. Im zweiten Fall präsentieren wir zwei Arten von Anwendungsbedingungen, einmal für allgemeine Regeln und einmal für eine bestimmte Menge von Regeln, die wir \emph{basic increasing rules} nennen. 
Anwendungsbedingungen für \emph{basic increasing rules} haben den Vorteil, dass diese weniger komplex und restriktiv sind als die Anwendungsbedingungen für allgemeine Regeln. Der Begriff von \emph{direct consistency-increase rules at layer} ist eine schwächere Version von \emph{direct consistency-increase rules} und führt zu weniger komplexen Anwendungsbedingungen.

Schließlich stellen wir einen \emph{rule-based graph repair} Ansatz vor, der in der Lage ist, bestimmte constraints, die wir \emph{circular conflict free constraints} nennen, und bestimmte Mengen von constraints, die wir \emph{circular conflict free set of constraints} nennen, zu reparieren.
Intuitiv ist ein constraint $c$ \emph{circular conflict free}, wenn es eine Ordnung $C_0, \ldots, C_n$ von allen Graphen von $c$ gibt, sodass kein $j <i$ existiert, so dass eine Reparatur eines Vorkommens von $C_i$ zur Einfügung einer neuen Verletzung von $C_j$ führen kann.
Analog ist eine Menge von constraints $\mathcal{C}$  \emph{circular conflict free}, wenn es eine Ordnung $c_1, \ldots, c_n$ von allen constraints von $\mathcal{C}$ gibt, so dass kein $j <i$ existiert, so dass die Reparatur von $c_i$ an einem Graphen, der bereits $c_j$ erfüllt,  nicht zu einem Graphen führen kann, der $c_j$ nicht erfüllt. 


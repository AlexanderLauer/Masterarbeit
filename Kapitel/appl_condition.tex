\section{Application Conditions}

\input{figures/fig_rules}
\input{figures/fig_appl_cond}

To guarantee that each transformation $t$ is (direct) consistency increasing or maintaining w.r.t to a constraint $c$, we present applications conditions ensuring this property. 
Given a constraint $c$, this application conditions are designed to only consider graph of $c$ up to a certain layer.
In particular, this is useful to reduce the restrictiveness of these application conditions, since all graphs $C_j$ of $c$ with $j > \kmax+2$ do not affect whether an transformation is considered as consistency maintaining or increasing. 
Additionally, in the case of consistency increasing application conditions, this design is necessary since it has to be ensured that violations at layer $\kmax +1$ will be removed.
Therefore, let us introduce a weaker notion of consistency increasing and maintaining rules, namely \emph{consistency increasing and maintaining rules at layer}.
As the name suggests, given a constraint $c$, a rule is consistency increasing or maintaining at layer $0 \leq k <\nlvl(c)$ if all of its applications at graphs $G$, with $\kmax = k$, are consistency increasing or maintaining w.r.t. $c$, respectively.
 

\begin{definition}[\textbf{consistency increasing and maintaining rule at layer}]
	Let a constraint $c$ be given. A rule $\rho$ is called \emph{consistency 
	maintaining at layer $0 \leq k < \nlvl(c)$ w.r.t. $c$} if all transformations
	$t : G \Longrightarrow_{\rho} H$, with $\maxk{G}{c} =k$, are consistency 
	maintaining w.r.t. $c$.
	Additionally, $\rho$ is called \emph{consistency increasing at layer $0 \leq k
	< \nlvl(c)$ w.r.t. $c$} if all transformations $t : G \Longrightarrow_{\rho}
	H$, with $\maxk{G}{c}=k$, are consistency increasing w.r.t. $c$.
	   
\end{definition}

Note, that a consistency maintaining rule at layer $\nlvl(c)-1$ w.r.t. $c$ 
is also a consistency maintaining or increasing rule w.r.t. $c$.
But, a consistency increasing rule at layer $\nlvl(c)-1$ must not necessarily be a consistency increasing rule w.r.t. $c$.

\input{Kapitel/application_conditions/general_ap}
\input{Kapitel/application_conditions/basic_rules}
\input{Kapitel/application_conditions/basic_ap}


%
%\begin{definition}[\textbf{overlap shift}]
%Let $\rho = L \xhookleftarrow{} K \xhookrightarrow{} R$ be a plain rule, $C$ a graph and $C'$ an overlap of $C$ and $L$ with morphisms $p : L \inj C'$, $k: K \inj C'$, $c:C \inj C'$ and the partial morphism $q: R \inj C'$. 
%We define 
%\begin{equation}
%\begin{split}
%	D := \{e \in C' \mid &(\exists e' \in L: p(e') = e \\ &\vee \exists e' \in R: q(e') = e) \\ &\wedge \exists e' \in C: c(e') = e \}
%\end{split}
%\end{equation}
%Let $r = L \xhookleftarrow{} K' \xhookrightarrow{} R$ be the rule with 
%$$K' := K \cup D$$
%The graph $H$ derived by the transformation $G \Rightarrow_{r,p} H$ is called the \emph{overlap shifted graph of $C'$ with $C$ and  $\rho$}.
%The overlap shifted graph of an graph $C$ is denoted by $\ols_{\rho}(C,C')$.
%\end{definition} 




%\begin{lemma}
%Let $G$ be a graph, $c$ a constraint in EANF, with $\maxc{G} < \nlvl(c)-1$,  and $\rho = L \xhookleftarrow{} K \xhookrightarrow{} R$ a plain rule.
%Let $d = \forall(a_k : C_{k-1} \inj C_{k}, \exists(b: C_{k} \inj C_{k+1}, e))$ be the subcondition of $c$ at layer $\cmax + 1$ and $\ap(\maxc{G} + 1, C')$ the application condition constructed by definition \ref{def_appl_cond} with $C'\in \mathcal{U}(C, C_{k+1})$.
%If 
%$$((R \setminus K) \cap C_{k+1}) \cup ((L \setminus K) \cap C_{k+1}) = \emptyset$$
%$\ap(\cmax, C')$ can be replaced by $\false$. 
%\end{lemma}
%\begin{proof}
%There does not exist an overlap $P$ of $C_k$ and $L$ with $i_L(L \setminus K) \cap i_{C_k}(C_k) \neq \emptyset$ and $\rep(P,C')$ will be equal to $\false$, if $C_k = C_{k+1}$, or equal to $\bigvee_{P' \in \mathbf{P}} \shift(\exists(i_R: R \inj P', \true), \rho)$. 
%Since the set $\mathbf{P}$ has to be empty, this expression can be replaced by $\false$. 
%If follows that $\rep(P,C') = \false$ for all $P \in \overlay(L,C_k)$ and therefore $\ap(\cmax, C')$ will always be evaluated to $\false$.
%\end{proof}

\input{Kapitel/pot_improving_rules}

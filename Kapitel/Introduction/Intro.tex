\section{Introduction}

Model-driven software engineering is a suitable tool to deal with the increasing complexity of software development processes. 
Graphs and graph transformations have emerged as a suitable framework for model-driven software engineering, where models are represented by graphs and changes of models are represented by graph transformations. 
These models need to be consistent with respect to certain constraints, e.g. multiplicities if the model represents an object diagram. 
The concept of nested graph constraints has proven to be suitable for expressing these constraints \cite{habel2005nested}.
As models are changed during development, the new model may become inconsistent and consistency must be restored.

The problem of restoring this consistency is called \emph{graph repair}: Given a constraint $c$ and an inconsistent graph $G$, derive a graph $H$ such that $H$ satisfies the constraint $c$.
In particular, we will consider the problem of \emph{rule-based graph repair}, which is defined as: Given a graph $G$, a constraint $c$ and a set of rules $\mathcal{R}$, derive a graph $H$ that satisfies $c$ using the rules of $\mathcal{R}$.
Because of the versatility of graphs and graph transformations, the concept of graph repair can be used to resolve inconsistencies for all kinds of graph-like structures. For example, in traffic light control or road networks. 

There are several rule-based graph repair approach and we will now briefly discuss some of them.
Habel and Pennemann have introduced the notions of \emph{consistency-preserving} and \emph{consistency-guaranteeing} transformations \cite{habel2009correctness}. As the name suggests, via these binary notions make it possible to decide whether a transformation guarantees or preserves the consistency of the derived graph. In addition, they presented application conditions which guarantee that a transformation via rules equipped with it them is consistency-preserving or consistency-maintaining respectively. 
Kosiol et al. have presented the graduated notions of \emph{consistency-sustaining} and \emph{consistency-improving} transformations and rules \cite{kosiol2022sustaining}. In contrast to the notions of consistency-preserving and consistency-guaranteeing it is possible to evaluate the magnitude of inconsistency of a graph. They have also presented consistency-sustaining application conditions. 
Nassar et al. have optimised the construction of the application conditions mentioned above \cite{nassar2020constructing}.
There is a rule-based graph repair approach for so-called proper constraints introduced by Sandmann and Habel \cite{sandmann2019rule}, but this approach is not able to repair multiple constraints. 
Nassar et al. have presented a repair approach to repair multiplicities for EMF models \cite{nassar2017rule,nassar2017rule1}. 

In this paper we will introduce a rule-based graph repair process for a certain subset of the set of nested conditions in alternating normal-form (ANF), so-called \emph{circular conflict free constraints}. 
The main idea of our approach is to increase the consistency of a graph level by level. That is, given a constraint $c = \forall(C_1, \exists(C_2, \forall(C_3, \exists(C_4, \ldots)))$ and a inconsistent graph $G$, in first step we repair the graph such that the derived graph satisfies $\forall(C_1, \exists(C_2, \true))$. In the next set, we repair the graph until it satisfies $\forall(C_1, \exists(C_2, \forall(C_3, \exists(C_4, \true)))$ and so on, until finally the derived graph satisfies $c$.
Note that we always repair two nesting levels at a time, since $\forall(C_1, \true)$ is always satisfied and $\forall(C_1, \false)$ immediately implies the satisfaction of $c$. Therefore, a process that repairs only one nesting level would return a consistent graph after at most two iterations, with the drawback that many occurrences of graphs are simply deleted. 

In order to do this, we will introduce  new notions of consistency, called \emph{consistency-maintaining} and \emph{consistency-increasing} transformations and rules. As the name suggests, \emph{consistency-maintaining} transformations do not decrease consistency, and  \emph{consistency-increasing} transformations actually increase the consistency. 
These notions are based on the first two levels of a constraint that are not satisfied. That is, given a graph $G$ that satisfies $\forall(C_1, \exists(C_2, \true))$ but not $\forall(C_1, \exists(C_2, \forall(C_3, \exists(C_4, \true)))$  only occurrences of $C_3$ are considered. This is because only occurrences of $C_3$ need to be repaired in order to derive a graph from $G$ that satisfies  $\forall(C_1, \exists(C_2, \forall(C_3, \exists(C_4, \true)))$. In particular, our notions are also able to detect the smallest changes in consistency, namely, the insertion or deletion of single elements, which will lead to a more consistent graph. 
Therefore, our notions are more fine-grained than the notions of consistency-preserving, consistency-guaranteeing, consistency-sustaining and consistency-improving transformations and rules. 

In addition, we will refine these notions to the notions of \emph{direct consistency-maintaining} and \emph{direct consistency-increasing} transformations and rules that completely prohibit the insertion of new violations. We will compare our new notions with those described above to ensure that they are indeed new notions of consistency, and to point out similarities and differences. 
We will present direct consistency-maintaining and two types of direct consistency-increasing application conditions. One for general rules and one for a specific set of rules called \emph{basic increasing rules}. For basic increasing rules, we are able to construct less restrictive and less complex direct consistency-increasing application conditions compared to the general ones. 

Finally, we present two rule-based graph repair approaches. The first for one constraint and the second for specific sets of constraints, called \emph{circular conflict free sets of constraints}, which uses our repair approach for one constraint. 
Both processes make use of a given set of rules $\mathcal{R}$ and we present a characterisation of when such a set of rules is able to repair the constraint or the set of constraints, respectively. Of course, this is only a sufficient criterion, since it depends strongly on the input graph whether a consistent graph can be derived by applying the rules of $\mathcal{R}$.



This paper is structured as follows:
Formal prerequisites are introduced in section \ref{preliminaries}. The notions of (direct) consistency-maintaining and (direct) consistency-increasing transformations and rules are given in section \ref{increase_maintainment} and the construction of application conditions and characterisation of basic rules is given in section \ref{appl_conds}. 
The repair process is presented in section \ref{repair}, and we summarise related graph repair approaches in section \ref{rel_work}, before concluding the paper with section \ref{conclusion}.
 